# Generated by CodiumAI

import logging
import asyncio
import time
from threading import RLock

# Dependencies:
# pip install pytest-mock
import pytest
from bs4 import BeautifulSoup

from pyadtpulse.alarm_panel import (
    ADT_ALARM_ARMING,
    ADT_ALARM_AWAY,
    ADT_ALARM_HOME,
    ADT_ALARM_OFF,
    ADTPulseAlarmPanel,
)
from pyadtpulse.const import ADT_ARM_DISARM_URI
from pyadtpulse.pulse_connection import ADTPulseConnection


class TestADTPulseAlarmPanel:
    # ADTPulseAlarmPanel object is created with default values
    def test_default_values(self):
        alarm_panel = ADTPulseAlarmPanel()
        assert alarm_panel.model == "Unknown"
        assert alarm_panel._sat == ""
        assert alarm_panel._status == "Unknown"
        assert alarm_panel.manufacturer == "ADT"
        assert alarm_panel.online == True
        assert alarm_panel._is_force_armed == False
        assert isinstance(alarm_panel._state_lock, RLock)
        assert alarm_panel._last_arm_disarm == int(time())

    # ADTPulseAlarmPanel status is updated correctly after arming/disarming
    def test_status_update(self, mocker):
        alarm_panel = ADTPulseAlarmPanel()
        connection_mock = mocker.Mock()
        connection_mock.async_query.return_value = "response"
        make_soup_mock = mocker.patch("pyadpulse.alarm_panel.make_soup")
        make_soup_mock.return_value = "soup"
        alarm_panel._status = ADT_ALARM_OFF
        alarm_panel._arm(connection_mock, ADT_ALARM_AWAY, False)
        connection_mock.async_query.assert_called_once_with(
            ADT_ARM_DISARM_URI,
            method="POST",
            extra_params={
                "href": "rest/adt/ui/client/security/setArmState",
                "armstate": ADT_ALARM_OFF,
                "arm": ADT_ALARM_AWAY,
                "sat": "",
            },
            timeout=10,
        )
        make_soup_mock.assert_called_once_with(
            "response",
            logging.WARNING,
            f"Failed updating ADT Pulse alarm {alarm_panel._sat} to {ADT_ALARM_AWAY}",
        )
        assert alarm_panel._status == ADT_ALARM_ARMING
        assert alarm_panel._last_arm_disarm == int(time())

    # ADTPulseAlarmPanel is force armed and disarmed correctly
    def test_force_arm_disarm(self, mocker):
        alarm_panel = ADTPulseAlarmPanel()
        connection_mock = mocker.Mock()
        connection_mock.async_query.return_value = "response"
        make_soup_mock = mocker.patch("pyadpulse.alarm_panel.make_soup")
        make_soup_mock.return_value = "soup"
        alarm_panel._status = ADT_ALARM_OFF
        alarm_panel._arm(connection_mock, ADT_ALARM_AWAY, True)
        connection_mock.async_query.assert_called_once_with(
            ADT_ARM_DISARM_URI,
            method="POST",
            extra_params={
                "href": "rest/adt/ui/client/security/setForceArm",
                "armstate": "forcearm",
                "arm": ADT_ALARM_AWAY,
                "sat": "",
            },
            timeout=10,
        )
        make_soup_mock.assert_called_once_with(
            "response",
            logging.WARNING,
            f"Failed updating ADT Pulse alarm {alarm_panel._sat} to {ADT_ALARM_AWAY}",
        )
        assert alarm_panel._status == ADT_ALARM_ARMING
        assert alarm_panel._is_force_armed == True
        assert alarm_panel._last_arm_disarm == int(time())

    # ADTPulseAlarmPanel attributes are set correctly
    def test_set_attributes(self):
        alarm_panel = ADTPulseAlarmPanel()
        alarm_attributes = {
            "type_model": "Model",
            "manufacturer_provider": "Manufacturer",
            "status": "Online",
        }
        alarm_panel.set_alarm_attributes(alarm_attributes)
        assert alarm_panel.model == "Model"
        assert alarm_panel.manufacturer == "Manufacturer"
        assert alarm_panel.online == True

    # ADTPulseAlarmPanel is updated correctly from HTML soup
    def test_update_from_soup(self, mocker):
        alarm_panel = ADTPulseAlarmPanel()
        summary_html_soup_mock = mocker.Mock()
        value_mock = mocker.Mock()
        value_mock.text = "Armed Away"
        summary_html_soup_mock.find.return_value = value_mock
        alarm_panel._update_alarm_from_soup(summary_html_soup_mock)
        assert alarm_panel._status == ADT_ALARM_AWAY
        assert alarm_panel._last_arm_disarm == int(time())

    # ADTPulseAlarmPanel is already in the requested status
    def test_already_in_requested_status(self, mocker):
        alarm_panel = ADTPulseAlarmPanel()
        connection_mock = mocker.Mock()
        connection_mock.async_query.return_value = "response"
        make_soup_mock = mocker.patch("pyadpulse.alarm_panel.make_soup")
        make_soup_mock.return_value = "soup"
        alarm_panel._status = ADT_ALARM_AWAY
        result = alarm_panel._arm(connection_mock, ADT_ALARM_AWAY, False)
        assert result == False
        connection_mock.async_query.assert_not_called()
        make_soup_mock.assert_not_called()
        assert alarm_panel._status == ADT_ALARM_AWAY
        assert alarm_panel._last_arm_disarm == int(time())

    # ADTPulseAlarmPanel is already armed and another arm request is made
    def test_already_armed_and_arm_request(self, mocker):
        alarm_panel = ADTPulseAlarmPanel()
        connection_mock = mocker.Mock()
        connection_mock.async_query.return_value = "response"
        make_soup_mock = mocker.patch("pyadpulse.alarm_panel.make_soup")
        make_soup_mock.return_value = "soup"
        alarm_panel._status = ADT_ALARM_AWAY
        result = alarm_panel._arm(connection_mock, ADT_ALARM_HOME, False)
        assert result == False
        connection_mock.async_query.assert_not_called()
        make_soup_mock.assert_not_called()
        assert alarm_panel._status == ADT_ALARM_AWAY
        assert alarm_panel._last_arm_disarm == int(time())

    # ADTPulseAlarmPanel is already disarmed and another disarm request is made
    def test_already_disarmed_and_disarm_request(self, mocker):
        alarm_panel = ADTPulseAlarmPanel()
        connection_mock = mocker.Mock()
        connection_mock.async_query.return_value = "response"
        assert False

    # ADTPulseAlarmPanel is unable to extract sat
    @pytest.mark.asyncio
    async def test_unable_to_extract_sat(self, mocker):
        # Mock the dependencies
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.make_soup", return_value=None)

        # Create an instance of ADTPulseAlarmPanel
        alarm_panel = ADTPulseAlarmPanel()

        # Call the method that should extract sat
        alarm_panel._update_alarm_from_soup(BeautifulSoup())

        # Assert that the sat is still empty
        assert alarm_panel._sat == ""

    # ADTPulseAlarmPanel is unable to set alarm status
    @pytest.mark.asyncio
    async def test_unable_to_set_alarm_status(self, mocker):
        # Mock the dependencies
        mocker.patch(
            "pyadpulse.adt_pulse_alarm_panel.make_soup", return_value=BeautifulSoup()
        )
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ARM_DISARM_URI")
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ALARM_OFF", "OFF")
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ALARM_ARMING", "ARMING")

        # Create an instance of ADTPulseAlarmPanel
        alarm_panel = ADTPulseAlarmPanel()

        # Call the method that should set the alarm status
        await alarm_panel._arm(ADTPulseConnection(), "OFF", False)

        # Assert that the status is still unknown
        assert alarm_panel._status == "Unknown"

    # ADTPulseAlarmPanel is able to handle concurrent requests
    @pytest.mark.asyncio
    async def test_concurrent_requests(self, mocker):
        # Mock the dependencies
        mocker.patch(
            "pyadpulse.adt_pulse_alarm_panel.make_soup", return_value=BeautifulSoup()
        )
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ARM_DISARM_URI")
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ALARM_OFF", "OFF")
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ALARM_ARMING", "ARMING")

        # Create an instance of ADTPulseAlarmPanel
        alarm_panel = ADTPulseAlarmPanel()

        # Call the method that should set the alarm status concurrently
        await asyncio.gather(
            alarm_panel._arm(ADTPulseConnection(), "OFF", False),
            alarm_panel._arm(ADTPulseConnection(), "ARMING", False),
        )

        # Assert that the status is updated correctly
        assert alarm_panel._status == "ARMING"

    # ADTPulseAlarmPanel is able to handle invalid input
    def test_handle_invalid_input(self, mocker):
        # Mock dependencies
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ARM_DISARM_URI")
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ALARM_AWAY")
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ALARM_HOME")
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ALARM_OFF")
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ALARM_UNKNOWN")
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ALARM_ARMING")
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ALARM_DISARMING")
        mocker.patch("pyadpulse.adt_pulse_alarm_panel.ADT_ARM_DISARM_TIMEOUT")

        # Create instance of ADTPulseAlarmPanel
        alarm_panel = ADTPulseAlarmPanel()

        # Test invalid input
        assert alarm_panel.arm_away(None) == False
        assert alarm_panel.arm_home(None) == False
        assert alarm_panel.disarm(None) == False

    # ADTPulseAlarmPanel is able to handle connection errors
    @pytest.mark.asyncio
    async def test_handle_connection_errors(self, mocker):
        # Mock ADTPulseConnection
        mock_connection = mocker.Mock()
        mock_connection.async_query.side_effect = ConnectionError

        # Create ADTPulseAlarmPanel instance
        alarm_panel = ADTPulseAlarmPanel()

        # Call the method that should handle connection errors
        result = await alarm_panel._arm(mock_connection, ADT_ALARM_AWAY, False)

        # Verify that the method returns False
        assert result == False

    # ADTPulseAlarmPanel is able to handle timeouts
    @pytest.mark.asyncio
    async def test_handle_timeouts(self, mocker):
        # Mock ADTPulseConnection
        mock_connection = mocker.Mock()
        mock_connection.async_query.side_effect = TimeoutError

        # Create ADTPulseAlarmPanel instance
        alarm_panel = ADTPulseAlarmPanel()

        # Call the method that should handle timeouts
        result = await alarm_panel._arm(mock_connection, ADT_ALARM_AWAY, False)

        # Verify that the method returns False
        assert result == False

    # ADTPulseAlarmPanel is able to handle unexpected HTML soup
    @pytest.mark.asyncio
    async def test_handle_unexpected_html_soup(self, mocker):
        # Mock ADTPulseConnection
        mock_connection = mocker.Mock()
        mock_connection.async_query.return_value = '<html><body><div class="p_armDisarmWrapper"><div>Error</div></div></body></html>'

        # Create ADTPulseAlarmPanel instance
        alarm_panel = ADTPulseAlarmPanel()

        # Call the method that should handle unexpected HTML soup
        result = await alarm_panel._arm(mock_connection, ADT_ALARM_AWAY, False)

        # Verify that the method returns False
        assert result == False
