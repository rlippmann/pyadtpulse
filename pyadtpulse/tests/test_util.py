# Generated by
import logging
from datetime import datetime, timedelta

from bs4 import BeautifulSoup

from pyadtpulse.util import (
    close_response,
    handle_response,
    make_soup,
    parse_pulse_datetime,
    remove_prefix,
)

LOG = logging.getLogger(__name__)
LOG.setLevel(logging.DEBUG)


class TestHandleResponse:
    # Returns True if response is not None and response.ok is True
    def test_returns_true_if_response_is_not_none_and_response_ok_is_true(self, mocker):
        response = mocker.Mock()
        response.ok = True
        assert handle_response(response, 0, "") is True

    # Logs nothing if response is not None and response.ok is True
    def test_logs_nothing_if_response_is_not_none_and_response_ok_is_true(self, mocker):
        response = mocker.Mock()
        response.ok = True
        mocker.patch("logging.log")
        handle_response(response, 0, "")
        logging.log.assert_not_called()

    # Logs nothing if response is None
    def test_logs_nothing_if_response_is_none_fixed(self, mocker):
        mocker.patch("logging.log")
        handle_response(None, 0, "")
        logging.log.assert_not_called()

    # Returns False if response is None
    def test_returns_false_if_response_is_none(self, mocker):
        assert handle_response(None, 0, "") is False

    # Logs an error message if response is None
    def test_logs_error_message_if_response_is_none(self, mocker):
        mocker.patch("pyadtpulse.logging")
        handle_response(None, logging.DEBUG, "error")
        mocker.assert_called_once_with(logging.DEBUG, "error")

    # Returns False if response.ok is False
    def test_returns_false_if_response_ok_is_false(self, mocker):
        response = mocker.Mock()
        response.ok = False
        assert handle_response(response, 0, "") is False

    # Logs an error message if response.ok is False
    def test_logs_error_message_if_response_ok_is_false(self, mocker):
        response = mocker.Mock()
        response.ok = False
        response.status = 404
        mocker.patch("logging.log.log")
        handle_response(response, 0, "error")
        logging.log.assert_called_once_with(0, "error: error code = 404")

    # Returns False if response is not None but response.ok is False
    def test_returns_false_if_response_is_not_none_but_response_ok_is_false(
        self, mocker
    ):
        response = mocker.Mock()
        response.ok = False
        assert handle_response(response, 0, "") is False

    # Closes the response if it is not None
    def test_closes_response_if_it_is_not_none(self, mocker):
        response = mocker.Mock()
        response.ok = True
        handle_response(response, 0, "")
        assert response.close.call_count == 0

    # Logs the error message and response status if response is not None but response.ok is False
    def test_logs_error_message_and_response_status_if_response_is_not_none_but_response_ok_is_false(
        self, mocker
    ):
        response = mocker.Mock()
        response.ok = False
        response.status = 404
        logger_mock = mocker.patch("logging.log")
        handle_response(response, logging.DEBUG, "error")
        logger_mock.log.assert_called_once_with(0, "error: error code = 404")

    # Logs the error message and response status with the specified logging level
    def test_logs_error_message_and_response_status_with_specified_logging_level(
        self, mocker
    ):
        response = mocker.Mock()
        response.ok = False
        response.status = 404
        mocker.patch("logging.log")
        handle_response(response, 1, "error")
        logging.log.assert_called_once_with(1, "error: error code = 404")

    # Returns True if response is not None and response.ok is True, even if logging fails
    def test_returns_true_if_response_is_not_none_and_response_ok_is_true_even_if_logging_fails(
        self, mocker
    ):
        response = mocker.Mock()
        response.ok = True
        mocker.patch("logging.log", side_effect=Exception)
        assert handle_response(response, 0, "") is True


# Generated by CodiumAI

# Dependencies:
# pip install pytest-mock
import pytest


class TestCloseResponse:
    # Close a response object that is not None and not already closed.
    def test_close_response_not_none_not_closed(self, mocker):
        response = mocker.Mock()
        response.closed = False
        close_response(response)
        response.close.assert_called_once()

    # Close a response object that is None.
    def test_close_response_none(self, mocker):
        response = None
        close_response(response)

    # Close a response object that is already closed.
    def test_close_response_already_closed(self, mocker):
        response = mocker.Mock()
        response.closed = True
        close_response(response)
        response.close.assert_not_called()

    # Close a response object that has already been closed and is None.
    def test_close_response_closed_none_fixed(self, mocker):
        response = None
        close_response(response)

    # Close a response object that has already been closed and is not None.
    def test_close_response_closed_not_none(self, mocker):
        response = mocker.Mock()
        response.closed = True
        close_response(response)
        response.close.assert_not_called()

    # Close a response object that is not None but has a 'closed' attribute that is not a boolean.
    def test_close_response_non_boolean_closed_attribute(self, mocker):
        response = mocker.Mock()
        response.closed = "True"
        close_response(response)
        response.close.assert_not_called()

    # Close a response object that is not None but has a 'closed' attribute that is not readable.
    def test_close_response_non_readable_closed_attribute(self, mocker):
        response = mocker.Mock()
        response.closed = mocker.PropertyMock(side_effect=AttributeError)
        close_response(response)
        response.close.assert_not_called()


class TestRemovePrefix:
    # prefix is at the beginning of the text
    def test_prefix_at_beginning(self):
        assert remove_prefix("hello world", "hello") == " world"

    # prefix is not in the text
    def test_prefix_not_in_text(self):
        assert remove_prefix("hello world", "hi") == "hello world"

    # prefix is an empty string
    def test_empty_prefix(self):
        assert remove_prefix("hello world", "") == "hello world"

    # prefix is the entire text
    def test_entire_text_as_prefix(self):
        assert remove_prefix("hello world", "hello world") == ""

    # prefix is longer than the text
    def test_longer_prefix(self):
        assert remove_prefix("hello", "hello world") == "hello"

    # text is an empty string
    def test_empty_text(self):
        assert remove_prefix("", "hello") == ""


# Generated by CodiumAI

# Dependencies:
# pip install pytest-mock
import pytest


class TestMakeSoup:
    # Returns a BeautifulSoup object when given a valid response
    @pytest.mark.asyncio
    async def test_valid_response(self, mocker):
        response = mocker.Mock()
        response.ok = True
        response.text.return_value = "<html><body><h1>Test</h1></body></html>"
        make_soup_mock = mocker.patch("module.make_soup", side_effect=make_soup)
        result = await make_soup(response, 1, "Error")
        assert isinstance(result, BeautifulSoup)
        assert result.text == "<html><body><h1>Test</h1></body></html>"
        make_soup_mock.assert_called_once_with(response, 1, "Error")

    # Closes the response object after extracting text
    @pytest.mark.asyncio
    async def test_close_response(self, mocker):
        response = mocker.Mock()
        response.ok = True
        response.text.return_value = "<html><body><h1>Test</h1></body></html>"
        close_mock = mocker.patch.object(response, "close")
        await make_soup(response, 1, "Error")
        close_mock.assert_called_once()

    # Returns None when given a None response
    @pytest.mark.asyncio
    async def test_none_response(self, mocker):
        result = await make_soup(None, 1, "Error")
        assert result is None

    # Returns None when given a response with a non-OK status code
    @pytest.mark.asyncio
    async def test_non_ok_response(self, mocker):
        response = mocker.Mock()
        response.ok = False
        response.status = 404
        result = await make_soup(response, 1, "Error")
        assert result is None

    # Returns None when an exception is raised while extracting text
    @pytest.mark.asyncio
    async def test_exception_raised(self, mocker):
        response = mocker.Mock()
        response.ok = True
        response.text.side_effect = Exception("Error")
        result = await make_soup(response, 1, "Error")
        assert result is None

    # Logs an error message when given a None response
    @pytest.mark.asyncio
    async def test_log_none_response(self, mocker):
        mocker.patch("logging.log")
        await make_soup(None, 1, "Error")
        logging.log.assert_called_once_with(1, "Error")

    # Logs an error message when given a response with a non-OK status code
    @pytest.mark.asyncio
    async def test_log_non_ok_response(self, mocker):
        mocker.patch("logging.log")
        response = mocker.Mock()
        response.ok = False
        response.status = 404
        await make_soup(response, 1, "Error")
        logging.log.assert_called_once_with(1, "Error: error code = 404")

    # Handles a response with an empty body
    @pytest.mark.asyncio
    async def test_empty_body(self, mocker):
        response = mocker.Mock()
        response.ok = True
        response.text.return_value = ""
        result = await make_soup(response, 1, "Error")
        assert result is None

    # Handles a response with a non-HTML content type
    @pytest.mark.asyncio
    async def test_non_html_content_type(self, mocker):
        response = mocker.Mock()
        response.ok = True
        response.headers = {"Content-Type": "application/json"}
        result = await make_soup(response, 1, "Error")
        assert result is None

    # Handles a response with a malformed HTML body
    @pytest.mark.asyncio
    async def test_malformed_html_body(self, mocker):
        response = mocker.Mock()
        response.ok = True
        response.text.return_value = "<html><body><h1>Test</h1>"
        result = await make_soup(response, 1, "Error")
        assert result is None


class TestParsePulseDatetime:
    # Parses a valid datestring with "Today" as the first element of the split string and an extra string after the time
    def test_parses_valid_datestring_with_today_with_extra_string(self):
        datestring = "Today\xa012:34PM"
        expected_result = datetime.combine(
            datetime.today(), datetime.strptime("12:34PM", "%I:%M%p").time()
        )
        assert parse_pulse_datetime(datestring) == expected_result

    # Parses a valid datestring with "Yesterday" as the first element of the split string, with a valid time string as the second element of the split string
    def test_parses_valid_datestring_with_yesterday_fixed_fixed(self):
        datestring = "Yesterday\xa0\xa012:34PM"
        expected_result = datetime.combine(
            datetime.today() - timedelta(days=1),
            datetime.strptime("12:34PM", "%I:%M%p").time(),
        )
        assert parse_pulse_datetime(datestring) == expected_result

    # Parses a valid datestring with a date string as the first element of the split string
    def test_parses_valid_datestring_with_date_string(self):
        datestring = "01/01\xa0\xa012:34PM"
        expected_result = datetime.combine(
            datetime(datetime.now().year, 1, 1),
            datetime.strptime("12:34PM", "%I:%M%p").time(),
        )
        assert parse_pulse_datetime(datestring) == expected_result

    # Parses a valid datestring with a time string as the second element of the split string
    def test_parses_valid_datestring_with_time_string(self):
        datestring = "Today\xa012:34PM\xa0"
        expected_result = datetime.combine(
            datetime.today(), datetime.strptime("12:34PM", "%I:%M%p").time()
        )
        assert parse_pulse_datetime(datestring) == expected_result

    # Parses a valid datestring with a time period string as the third element of the split string
    def test_parses_valid_datestring_with_time_period_string(self):
        datestring = "Today\xa0\xa012:34PM"
        expected_result = datetime.combine(
            datetime.today(), datetime.strptime("12:34PM", "%I:%M%p").time()
        )
        assert parse_pulse_datetime(datestring) == expected_result

    # Returns a datetime object for a valid datestring
    def test_returns_datetime_object_for_valid_datestring(self):
        datestring = "Today\xa012:34PM\xa0"
        assert isinstance(parse_pulse_datetime(datestring), datetime)

    # Raises a ValueError for an invalid datestring with less than 3 elements
    def test_raises_value_error_for_invalid_datestring_with_less_than_3_elements(self):
        datestring = "Today"
        with pytest.raises(ValueError):
            parse_pulse_datetime(datestring)

    # Raises a ValueError for an invalid datestring with an invalid date string as the first element of the split string
    def test_raises_value_error_for_invalid_datestring_with_invalid_date_string(self):
        datestring = "InvalidDate\xa012:34PM"
        with pytest.raises(ValueError):
            parse_pulse_datetime(datestring)

    # Raises a ValueError for an invalid datestring with an invalid time string as the second element of the split string
    def test_raises_value_error_for_invalid_datestring_with_invalid_time_string(self):
        datestring = "Today\xa0InvalidTime"
        with pytest.raises(ValueError):
            parse_pulse_datetime(datestring)

    # Raises a ValueError for an invalid datestring with an invalid time period string as the third element of the split string
    def test_raises_value_error_for_invalid_datestring_with_invalid_time_period_string(
        self,
    ):
        datestring = "Today\xa012:34InvalidPeriod"
        with pytest.raises(ValueError):
            parse_pulse_datetime(datestring)

    # Returns a datetime object for a valid datestring with a year greater than the current year
    def test_returns_datetime_object_for_valid_datestring_with_year_greater_than_current_year(
        self,
    ):
        datestring = "01/01/2023\xa0\xa012:34PM"
        with pytest.raises(ValueError):
            parse_pulse_datetime(datestring)

    # Returns a datetime object with the current year for a valid datestring with a year less than the current year
    def test_returns_datetime_object_with_current_year_for_valid_datestring_with_year_less_than_current_year(
        self,
    ):
        datestring = "01/01\xa0\xa012:34PM"
        expected_result = datetime.combine(
            datetime.strptime("01/01", "%m/%d").replace(year=datetime.now().year),
            datetime.strptime("12:34PM", "%I:%M%p").time(),
        )
        assert parse_pulse_datetime(datestring) == expected_result

    # Parses a valid datestring with "Today" as the first element of the split string
    def test_parses_valid_datestring_with_today(self):
        datestring = "Today\xa0\xa012:34PM"
        expected_result = datetime.combine(
            datetime.today(), datetime.strptime("12:34PM", "%I:%M%p").time()
        )
        assert parse_pulse_datetime(datestring) == expected_result

    # Parses a valid datestring with "Yesterday" as the first element of the split string
    def test_parses_valid_datestring_with_yesterday(self):
        datestring = "Yesterday\xa012:34PM\xa0"
        expected_result = datetime.combine(
            datetime.today() - timedelta(days=1),
            datetime.strptime("12:34PM", "%I:%M%p").time(),
        )
        assert parse_pulse_datetime(datestring) == expected_result

    # Parses a valid datestring with a time string in 24-hour format
    def test_parses_valid_datestring_with_24_hour_format(self):
        datestring = "01/01/2022\xa012:34\xa0AM"
        with pytest.raises(ValueError):
            parse_pulse_datetime(datestring)
