# Generated by CodiumAI
from multiprocessing import RLock
from time import time

# Dependencies:
# pip install pytest-mock
import pytest

from pyadtpulse.alarm_panel import ADTPulseAlarmPanel
from pyadtpulse.const import DEFAULT_API_HOST
from pyadtpulse.gateway import ADTPulseGateway
from pyadtpulse.pulse_authentication_properties import PulseAuthenticationProperties
from pyadtpulse.pulse_connection import PulseConnection
from pyadtpulse.pulse_connection_properties import PulseConnectionProperties
from pyadtpulse.pulse_connection_status import PulseConnectionStatus
from pyadtpulse.site_properties import ADTPulseSiteProperties
from pyadtpulse.zones import ADTPulseFlattendZone, ADTPulseZoneData, ADTPulseZones


class TestADTPulseSiteProperties:
    # Retrieve site id and name
    def test_retrieve_site_id_and_name(self):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        # Act
        retrieved_id = site_properties.id
        retrieved_name = site_properties.name

        # Assert
        assert retrieved_id == site_id
        assert retrieved_name == site_name

    # Retrieve last update time
    def test_retrieve_last_update_time(self):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        # Act
        last_updated = site_properties.last_updated

        # Assert
        assert isinstance(last_updated, int)

    # Retrieve all zones registered with ADT Pulse account when zones exist
    def test_retrieve_all_zones_with_zones_fixed(self):
        # Arrange

        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        # Add some zones to the site_properties instance
        zone1 = ADTPulseZoneData(id_=1, name="Front Door")
        zone2 = ADTPulseZoneData(id_=2, name="Back Door")

        site_properties._zones[1] = zone1
        site_properties._zones[2] = zone2

        # Act
        zones = site_properties.zones

        # Assert
        assert isinstance(zones, list)
        assert len(zones) == 2

    # Retrieve zone information in dictionary form
    def test_retrieve_zone_information_as_dict(self):
        # Arrange

        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)
        site_properties._zones = ADTPulseZones()
        zone = ADTPulseZoneData(id_=1, name="Zone1")  # Provide the 'id_' argument
        site_properties._zones[1] = zone

        # Act
        zones_dict = site_properties.zones_as_dict

        # Assert
        assert isinstance(zones_dict, ADTPulseZones)

    # Retrieve alarm panel object for the site
    def test_retrieve_alarm_panel_object(self):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        # Act
        alarm_panel = site_properties.alarm_control_panel

        # Assert
        assert isinstance(alarm_panel, ADTPulseAlarmPanel)

    # Retrieve gateway device object
    def test_retrieve_gateway_device_object(self):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        # Act
        gateway = site_properties.gateway

        # Assert
        assert isinstance(gateway, ADTPulseGateway)

    # No zones exist
    def test_no_zones_exist(self):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        # Act & Assert
        with pytest.raises(RuntimeError):
            site_properties.zones

    # Attempting to retrieve site data while another thread is modifying it
    def test_retrieve_site_data_while_modifying(self, mocker):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        def modify_site_data():
            with site_properties.site_lock:
                time.sleep(2)
                site_properties._last_updated = int(time())

        mocker.patch.object(site_properties, "_last_updated", 0)
        mocker.patch.object(site_properties, "_site_lock", RLock())

        # Act
        with site_properties.site_lock:
            retrieved_last_updated = site_properties.last_updated

        # Assert
        assert retrieved_last_updated == 0

    # Attempting to set alarm status to existing status
    def test_set_alarm_status_to_existing_status(self, mocker):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        mocker.patch.object(site_properties._alarm_panel, "_status", "Armed Away")

    # Check if updates exist
    def test_check_updates_exist(self, mocker):
        # Arrange
        from time import time

        site_properties = ADTPulseSiteProperties("12345", "My ADT Pulse Site")
        mocker.patch.object(site_properties, "_last_updated", return_value=time())

        # Act
        result = site_properties.updates_may_exist

        # Assert
        assert result is False

    # Update site/zone data async with current data
    @pytest.mark.asyncio
    async def test_update_site_zone_data_async(self, mocker):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)
        mock_zones = mocker.Mock()
        mock_zones.flatten.return_value = [ADTPulseFlattendZone()]
        site_properties._zones = mock_zones

        # Act
        result = await site_properties.async_update()

        # Assert
        assert result == False

    # Cannot set alarm status from one state to another
    @pytest.mark.asyncio
    async def test_cannot_set_alarm_status(self, mocker):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)
        cp = PulseConnectionProperties(DEFAULT_API_HOST)
        cs = PulseConnectionStatus()
        pa = PulseAuthenticationProperties(
            "test@example.com", "testpassword", "testfingerprint"
        )

        connection = PulseConnection(cs, cp, pa)

        # Act
        result = await site_properties._alarm_panel._arm(
            connection, "Armed Home", False
        )

        # Assert
        assert result == False

    # Failed updating ADT Pulse alarm to new mode
    @pytest.mark.asyncio
    async def test_failed_updating_alarm_mode(self, mocker):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        # Mock the _arm method to return False
        async def mock_arm(*args, **kwargs):
            return False

        mocker.patch.object(ADTPulseAlarmPanel, "_arm", side_effect=mock_arm)

        # Act
        result = await site_properties.alarm_control_panel._arm(None, "new_mode", False)

        # Assert
        assert result == False

    # Retrieve last update time with invalid input
    def test_retrieve_last_update_invalid_input(self):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        # Act
        last_updated = site_properties.last_updated

        # Assert
        assert last_updated == 0

    # Retrieve site id and name with invalid input
    def test_retrieve_site_id_and_name_with_invalid_input(self):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        # Act
        retrieved_id = site_properties.id
        retrieved_name = site_properties.name

        # Assert
        assert retrieved_id == site_id
        assert retrieved_name == site_name

    # Retrieve zone information in dictionary form with invalid input
    def test_retrieve_zone_info_invalid_input(self, mocker):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)
        mocker.patch.object(site_properties, "_zones", None)

        # Act and Assert
        with pytest.raises(RuntimeError):
            site_properties.zones

        with pytest.raises(RuntimeError):
            site_properties.zones_as_dict

    # Retrieve all zones registered with ADT Pulse account with invalid input
    def test_retrieve_zones_with_invalid_input(self, mocker):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)
        mocker.patch.object(site_properties, "_zones", None)

        # Act and Assert
        with pytest.raises(RuntimeError):
            _ = site_properties.zones

        with pytest.raises(RuntimeError):
            _ = site_properties.zones_as_dict

    # Retrieve alarm panel object for the site with invalid input
    def test_retrieve_alarm_panel_invalid_input(self, mocker):
        # Arrange
        site_id = "12345"
        site_name = "My ADT Pulse Site"
        site_properties = ADTPulseSiteProperties(site_id, site_name)

        # Mock the ADTPulseAlarmPanel object
        mock_alarm_panel = mocker.Mock()
        site_properties._alarm_panel = mock_alarm_panel

        # Act
        retrieved_alarm_panel = site_properties.alarm_control_panel

        # Assert
        assert retrieved_alarm_panel == mock_alarm_panel
